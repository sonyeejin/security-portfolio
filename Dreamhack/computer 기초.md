# dream beginner

wed해킹: 웹 서버와  클라이언트 사이에 발생하는 취약점을 이용한 공격

system해킹: 소프트웨어의 취약점을 찾아 공격

reverse engineering: 프로그램을 역으로 분석하여 작동원리 알아내는 기술, 취약점 파악이나 악성 행동을 분석하는 데 사용됨

write up: 해킹 문제에서 플래그 찾는(문제 풀이)과정 정리한 것

## 진법
한 자릿수에 표현할 수 있는 숫자의 개수를 나타냄 -> n진법은 0부터 n-1까지의 숫자나 문자로 나타내는 것

2진법은 0,1의 조합으로 숫자를 나타낼 수 있음
2진수로 숫자를 표현할 때 보통 0b라는 접두어를 붙여 사용함 ex) 10진수 7은 2진수로 0b111로 표기

16진법은 0부터9,A부터F로 수를 표현하는 것 -> 2진수 0b1100은 16진수로 0xC로 표기한다

1. 2진수 -> 10진수 변환

2진수 01011000인 경우

<img width="740" height="183" alt="스크린샷 2025-08-02 오후 3 31 17" src="https://github.com/user-attachments/assets/c497570c-d666-4857-9d23-e6a3b729bc75" />
2진수에서 숫자가 1인 부분의 값만 더해주면 됨 -> 64+16+8=88

2. 10진수 -> 2진수 변환

<img width="554" height="650" alt="image" src="https://github.com/user-attachments/assets/8c129d41-d3e2-4020-a854-ec27c10123ef" />

10진수 숫자를 2로 나누는데, 더는 나누어지지 않을 때까지 반복한다. 이후 몫과 나머지 숫자들을 역순으로 써주면 됨

3. 2진수 -> 16진수 변환

2진수 11100이 있다고 하자. 이를 4자리씩 끊는다 -> 0001,1100
끊어준 숫자를 각 10진수로 나타낸다(제일 오른쪽부터 2의 0승..이런식으로 두고 1인부분만 계산하면 됨) -> 0001은 1, 1100은 12
10진수로 표현된 각 숫자에 대응되는 16진수 값으로 변환함-> 1은 1 ,12는 C로

즉, 11100(2)는 16진수로 0x1C(16)가 된다
<img width="994" height="756" alt="image" src="https://github.com/user-attachments/assets/8f2738cb-3580-4630-99a2-e7aedc522cbb" />

4. 16진수 -> 10진수 변환
16진수인 0x 1A4가 있다고 하자
<img width="1636" height="236" alt="image" src="https://github.com/user-attachments/assets/60bc8b9c-6c8f-457f-8fe9-c435f5e9dbeb" />
알아둬야할 건 오른쪽부터 자릿수가 16의 0승,,,16의 3승까지 주어진다는 것임
이제 10진수를 계산하는 방법은 숫자랑 각 자릿수를 곱하고 각각의 값을 더해주면 됨
<img width="666" height="294" alt="image" src="https://github.com/user-attachments/assets/3e45cc14-ca27-4bc6-b8c3-2e5de8d15ce9" />


출처: https://jerryjerryjerry.tistory.com/170

## 비트,바이트
비트(bit)는 컴퓨터에서 사용하는 데이터의 최소단위다. 
바이트(byte)는 비트 8개로 구성되며 이는 메모리에 저장되는 최소단위다.
1바이트는 2^8=256 가지의 숫자를 표기할 수 있음

MSB:최상위 비트로 이진데이터에서 제일 왼쪽에 있는 비트를 의미( 최상위인 이유는 제일 왼쪽 숫자가 숫자의 크기에 가장큰 영향을 줘서)
LSB:최하위 비트로 제일 오른쪽에 있는 비트 의미

부호가 있는 데이터(signed 데이터) 의 경우 MSB가 0이면 양수,1이면 음수를 나타냄

2진수 10010100이 있을 때,
_부호가 없는 데이터_ 인 경우 2의7승 + 2의4승+ 2의2승= 128+16+4=148
_부호가 있는 데이터(+또는 -)_ 인 경우 2의 보수를 사용해서 구해야 함 
-> 여기서 _2의 보수란_ 0과 1이 역변환 된 것을 의미함 즉, 위의 숫자를 01101011로 바꾼 뒤 +1을 해준 수를 의미한다
최종적으로 01101100으로 108이 된다-> -108

## 바이트 오더링(byte odering)
2바이트 이상의 데이터는 메모리에 연속적 저장됨 이때 각 바이트가 메모리에 정렬되는 방식이 바이트 오더링임
빅 엔디안과 리틀 엔디안이 존재

_빅엔디안_ 은 큰 바이트부터 낮은 주소에 저장됨을 의미( 리틀 엔디안은 낮은 바이트가 낮은 주소에 저장)

가장 왼쪽에 있는 바이트가 MSB인데 이 MSB는 앞선 내용에서의 bit가 아닌 byte를 의미함을 주의한다-> 빅 엔디안은 이 MSB(가장 왼쪽의 큰 바이트) 부터 낮은 주소에 저장됨을 의미한다

데이터 0x1234567의 경우 (MSB는 0x01)
<img width="1164" height="456" alt="image" src="https://github.com/user-attachments/assets/0fd5e8fa-4d97-4366-a0da-ddf4df83149f" />

<img width="1268" height="480" alt="image" src="https://github.com/user-attachments/assets/d38cc665-b3d3-435d-be62-65d5afb45b46" />

* 아스키 코드
문자열 "ABCD" 에서
<img width="1220" height="432" alt="image" src="https://github.com/user-attachments/assets/f49405d2-641b-43fb-87a3-59855f43a340" />

-> 10진수 65 (문자 A)는 2진수로 01000001 => 쪼개면 0100,0001 고 각 10진수로 4와1임 => 10진수 4와1은 16진수로도 동일하므로 0x41이 됨

### < 바이트오더링 예시 >
<img width="1180" height="734" alt="image" src="https://github.com/user-attachments/assets/e3f4c737-c41d-4617-bb03-e6eb011086f5" />

다음 코드에서 문자열 "ABCD"과 정수 데이터 0x41424344가 메모리에 저장되며 리틀엔디안을 따른다.(맨 오른쪽의 LSB부터 낮은 주소에 저장됨)
-> 해당 숫자는 16진수 41424344인데 실제 메모리 주소에는 44434241 으로 저장이 되고 해석을 41424344로 하는 것임 

<img width="918" height="598" alt="image" src="https://github.com/user-attachments/assets/fa4e5f3d-90c9-4da6-9340-606a2dde94de" />

주의할 점 : 변수 str에는 문자열을 저장하는데, 문자열 저장시에는 바이트 오더링을 고려하지 않으므로 ABCD는 41424344순서대로 메모리에 저장
하지만 문자열이 아닌 데이터 16진수 0x41424344는 리틀엔디안 방식을 따르며 실제 메모리에 44434241로 저장됨을 알 수 있다.

## 비트 연산
피연산자를 2진수로 표현하여 비트 단위로 연산하는 것

1. 논리 연산 : true(1)과 false(0) 반환함
   
|| : or의 의미로 둘 중 하나라도 참이면 참

&&: and의 의미로 둘 다 참이여야 참

!: not의 의미로 참이면 거짓이고 거짓이면 참

2. 비트 연산: 1은 참,0은 거짓
   
|: or

&: and

^:xor의 의미로 두 값이 같으면 0, 다르면 1임

~: not

3. 시프트 연산
x<<n: 왼쪽으로 n만큼 이동, 오른쪽은 0으로 채움 == x에 2의 n승을 곱한것과 동일함

x>>n(산술 시프트) : 오른쪽으로 n만큼 이동, 왼쪽은 MSB와 동일한 값으로 채움 == x를 2의 n승으로 나눈값과 동일함(음수 부호 유지)

x>>>n(논리 시프트) : 오른쪽으로 n만큼 이동, 왼쪽은 모두 0으로 채움(음수 부호가 유지되지 않음)


### < 비트 마스킹 >

어떤 데이터의 틁정 위치의 비트만 표시하거나 가리는 연산
1. and연산(&)을 활용하여 특정 비트만 남겨보자
   
2바이트의 0xABCD가 존재할 때 상위 8비트를 없애고 하위 8비트에 해당하는 0xCD만 남기기

주어진 데이터와 0x00FF( 0000000011111111) 를 &연산해주면 된다.

<img width="1330" height="520" alt="image" src="https://github.com/user-attachments/assets/ea0cc12e-a2fb-45c4-ab45-f452e015a7c7" />

2. 32비트(4바이트)의 데이터 0x12345678 가 존재할 때, 상위 1바이트의 데이터( 0x12) 만 가져오는 방법

방1) 24번 우측으로 논리 시프트 수행한다 >>>24

방2) 24번 우측으로 산술 시프트 >>24 후, 0x000000FF와 and 연산 하기

<img width="1262" height="112" alt="image" src="https://github.com/user-attachments/assets/4c8a4445-e67b-4c89-b44f-c29a94f9e7ed" />


## 인코딩,디코딩 

encofing은 데이터를 특정 형식으로 변환하는 것(ex. 압축), decoding하여 원래의 값 구할 수 있다.
암호화는 데이터의 기밀성을 목적으로 하며 오직 '비밀키'를 사용해야 원문을 구할 수 있지만, 인코딩은 데이터를 효율적으로 다룰 수 있게 하며 누구나 '표준화된 방식'으로 원문을 구할 수 있다.

### 1. 아스키 코드 

:문자 -> 숫자로 변환하는 문자 인코딩의 표준(문자를 숫자로 변환할 수 있어야 글자를 0과1로 표현할 수 있음)
아스키 문자 1개는 1바이트 크기 => 7비트는 문자,1비트는 오류 체크로 사용.
해당되는 문자로는 공백,느낌표,영문,괄호 등이 있다. 각 문자는 10진수 값을 가짐.
<img width="1524" height="456" alt="image" src="https://github.com/user-attachments/assets/8c44de06-82e6-42f5-a777-904ca8cff1d0" />
-> 24비트의 2진수는 3바이트로 3개의 아스키 문자로 구성. 각 문자는 10진수로 99,97,116이고 이는 cat을 의미

### 2. 유니코드

문자가 다양해지며 아스키 코드의 한계로 등장함.
유니코드는 영어 뿐 아니라 전세계 모든 언어 문자에 고유 번호를 부여하는 국제 표준 코드.U+ 뒤에 문자에 해당하는 숫자를 16진수로 표기.
최대 32비트로 문자 1개 표현 가능(4바이트)
UTF-8/16/32 와 같이 다양한 인코딩 형식 존재. 뒤에 붙은 숫자는 비트를 의미

### URL인코딩

웹에서 사용되는 URL은 특정 형식의 문자열만 허용. URL인코딩을 통해 문자열을 인터넷으로 전송 가능한 형식으로 변환한다.
인코딩이 필요한 특수문자로는 :/?#[]@! 등..이 있다. %기호 뒤에 인코딩 해야하는 문자의 아스키 코드 16진수 값을 붙여 나타냄
ex) 공백 문자 인코딩 -> %20으로 표기

### Base64 인코딩 

이진 데이터를 아스키 문자로 구성된 텍스트로 변환하는 인코딩 방식.
64개의 아스키 문자가 인코딩에 사용됨( 알파벳 대소문자 52개 ,숫자 10개,+,/ )

* base64 인코딩 방식
  1) 원본 이진 데이터에서 6비트씩 끊어서 묶음. 0을 뒤에 추가하여 6의 배수로 만듦.
  2) 6비트로 이루어진 이진 데이터들을 숫자로 변환 후, base64 테이블에 해당하는 문자를 찾아 치환.
  3) 글자 수가 4의 배수가 되도록 문자 =를 반복하여 뒤에 추가 (패딩padding)

## 운영체제(OS)

사용자를 위해 특정한 기능을 수행하는 프로그램을 응용 프로그램이라고 함. 
이런 응용 프로그램의 동작을 수행하고 시스템 자원 할당 등의 관리 작업을 사용자가 아닌 '운영체제'라는 소프트웨어가 함
사용자 및 응프는 하드웨어(CPU,메모리,입출력 장치 등)에 직접 점근하지 않음

OS는 하드웨어 자원을 효율적으로 사용할 수 있도록 분배,할당 하여 성능을 높인다.
-> 실행중인 프로그램(프로세스)에 CPU를 번갈아 할당해야할 때, 어떤 프로세스에 할당할 지 결정
   메모리 공간을 각 프로세스에 어떻게 분배 할 지
   컴퓨터와 입출력 장치 간 정보 공유 과정 관리 등

OS는 크게 커널(kernal)과 셸(shell)로 나눌 수 있음
* 커널은 하드웨어 관리를 실제로 수행하며 소웨와 하웨 간 소통을 관리, 시스템 부팅~종료까지 실행됨
* 셸은 사용자와 커널 사이에서 사용자가 OS에 명령을 내리도록 interface역할을 함

<img width="754" height="490" alt="image" src="https://github.com/user-attachments/assets/80094f46-b708-4922-b7d2-0df5815d54c6" />

### 운영체제 종류
크게 windows와 UNIX/Linux 계열 운영체제로 나눔
윈도우는 마이크로소프트사에서 개발,GUI제공하여 사용자가 편리하게 사용
유닉스는 벨 연구소에서 개발, 대부분 운영체제는 이로부터 발전-> 리눅스,mac OS,android,iOS 등












