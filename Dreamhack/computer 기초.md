# dream beginner

wed해킹: 웹 서버와  클라이언트 사이에 발생하는 취약점을 이용한 공격

system해킹: 소프트웨어의 취약점을 찾아 공격

reverse engineering: 프로그램을 역으로 분석하여 작동원리 알아내는 기술, 취약점 파악이나 악성 행동을 분석하는 데 사용됨

write up: 해킹 문제에서 플래그 찾는(문제 풀이)과정 정리한 것

## 진법
한 자릿수에 표현할 수 있는 숫자의 개수를 나타냄 -> n진법은 0부터 n-1까지의 숫자나 문자로 나타내는 것

2진법은 0,1의 조합으로 숫자를 나타낼 수 있음
2진수로 숫자를 표현할 때 보통 0b라는 접두어를 붙여 사용함 ex) 10진수 7은 2진수로 0b111로 표기

16진법은 0부터9,A부터F로 수를 표현하는 것 -> 2진수 0b1100은 16진수로 0xC로 표기한다

1. 2진수 -> 10진수 변환

2진수 01011000인 경우

<img width="740" height="183" alt="스크린샷 2025-08-02 오후 3 31 17" src="https://github.com/user-attachments/assets/c497570c-d666-4857-9d23-e6a3b729bc75" />
2진수에서 숫자가 1인 부분의 값만 더해주면 됨 -> 64+16+8=88

2. 10진수 -> 2진수 변환

<img width="554" height="650" alt="image" src="https://github.com/user-attachments/assets/8c129d41-d3e2-4020-a854-ec27c10123ef" />

10진수 숫자를 2로 나누는데, 더는 나누어지지 않을 때까지 반복한다. 이후 몫과 나머지 숫자들을 역순으로 써주면 됨

3. 2진수 -> 16진수 변환

2진수 11100이 있다고 하자. 이를 4자리씩 끊는다 -> 0001,1100
끊어준 숫자를 각 10진수로 나타낸다(제일 오른쪽부터 2의 0승..이런식으로 두고 1인부분만 계산하면 됨) -> 0001은 1, 1100은 12
10진수로 표현된 각 숫자에 대응되는 16진수 값으로 변환함-> 1은 1 ,12는 C로

즉, 11100(2)는 16진수로 0x1C(16)가 된다
<img width="994" height="756" alt="image" src="https://github.com/user-attachments/assets/8f2738cb-3580-4630-99a2-e7aedc522cbb" />

4. 16진수 -> 10진수 변환
16진수인 0x 1A4가 있다고 하자
<img width="1636" height="236" alt="image" src="https://github.com/user-attachments/assets/60bc8b9c-6c8f-457f-8fe9-c435f5e9dbeb" />
알아둬야할 건 오른쪽부터 자릿수가 16의 0승,,,16의 3승까지 주어진다는 것임
이제 10진수를 계산하는 방법은 숫자랑 각 자릿수를 곱하고 각각의 값을 더해주면 됨
<img width="666" height="294" alt="image" src="https://github.com/user-attachments/assets/3e45cc14-ca27-4bc6-b8c3-2e5de8d15ce9" />


출처: https://jerryjerryjerry.tistory.com/170

## 비트,바이트
비트(bit)는 컴퓨터에서 사용하는 데이터의 최소단위다. 
바이트(byte)는 비트 8개로 구성되며 이는 메모리에 저장되는 최소단위다.
1바이트는 2^8=256 가지의 숫자를 표기할 수 있음

MSB:최상위 비트로 이진데이터에서 제일 왼쪽에 있는 비트를 의미( 최상위인 이유는 제일 왼쪽 숫자가 숫자의 크기에 가장큰 영향을 줘서)
LSB:최하위 비트로 제일 오른쪽에 있는 비트 의미

부호가 있는 데이터(signed 데이터) 의 경우 MSB가 0이면 양수,1이면 음수를 나타냄

2진수 10010100이 있을 때,
_부호가 없는 데이터_ 인 경우 2의7승 + 2의4승+ 2의2승= 128+16+4=148
_부호가 있는 데이터(+또는 -)_ 인 경우 2의 보수를 사용해서 구해야 함 
-> 여기서 _2의 보수란_ 0과 1이 역변환 된 것을 의미함 즉, 위의 숫자를 01101011로 바꾼 뒤 +1을 해준 수를 의미한다
최종적으로 01101100으로 108이 된다-> -108

## 바이트 오더링(byte odering)
2바이트 이상의 데이터는 메모리에 연속적 저장됨 이때 각 바이트가 메모리에 정렬되는 방식이 바이트 오더링임
빅 엔디안과 리틀 엔디안이 존재

_빅엔디안_ 은 큰 바이트부터 낮은 주소에 저장됨을 의미( 리틀 엔디안은 낮은 바이트가 낮은 주소에 저장)

가장 왼쪽에 있는 바이트가 MSB인데 이 MSB는 앞선 내용에서의 bit가 아닌 byte를 의미함을 주의한다-> 빅 엔디안은 이 MSB(가장 왼쪽의 큰 바이트) 부터 낮은 주소에 저장됨을 의미한다

데이터 0x1234567의 경우 (MSB는 0x01)
<img width="1164" height="456" alt="image" src="https://github.com/user-attachments/assets/0fd5e8fa-4d97-4366-a0da-ddf4df83149f" />

<img width="1268" height="480" alt="image" src="https://github.com/user-attachments/assets/d38cc665-b3d3-435d-be62-65d5afb45b46" />

* 아스키 코드
문자열 "ABCD" 에서
<img width="1220" height="432" alt="image" src="https://github.com/user-attachments/assets/f49405d2-641b-43fb-87a3-59855f43a340" />

-> 10진수 65 (문자 A)는 2진수로 01000001 => 쪼개면 0100,0001 고 각 10진수로 4와1임 => 10진수 4와1은 16진수로도 동일하므로 0x41이 됨

### < 바이트오더링 예시 >
<img width="1180" height="734" alt="image" src="https://github.com/user-attachments/assets/e3f4c737-c41d-4617-bb03-e6eb011086f5" />

다음 코드에서 문자열 "ABCD"과 정수 데이터 0x41424344가 메모리에 저장되며 리틀엔디안을 따른다.(맨 오른쪽의 LSB부터 낮은 주소에 저장됨)
-> 해당 숫자는 16진수 41424344인데 실제 메모리 주소에는 44434241 으로 저장이 되고 해석을 41424344로 하는 것임 

<img width="918" height="598" alt="image" src="https://github.com/user-attachments/assets/fa4e5f3d-90c9-4da6-9340-606a2dde94de" />

주의할 점 : 변수 str에는 문자열을 저장하는데, 문자열 저장시에는 바이트 오더링을 고려하지 않으므로 ABCD는 41424344순서대로 메모리에 저장
하지만 문자열이 아닌 데이터 16진수 0x41424344는 리틀엔디안 방식을 따르며 실제 메모리에 44434241로 저장됨을 알 수 있다.

## 비트 연산
피연산자를 2진수로 표현하여 비트 단위로 연산하는 것

1. 논리 연산 : true(1)과 false(0) 반환함
   
|| : or의 의미로 둘 중 하나라도 참이면 참

&&: and의 의미로 둘 다 참이여야 참

!: not의 의미로 참이면 거짓이고 거짓이면 참

2. 비트 연산: 1은 참,0은 거짓
   
|: or

&: and

^:xor의 의미로 두 값이 같으면 0, 다르면 1임

~: not

3. 시프트 연산
x<<n: 왼쪽으로 n만큼 이동, 오른쪽은 0으로 채움 == x에 2의 n승을 곱한것과 동일함

x>>n(산술 시프트) : 오른쪽으로 n만큼 이동, 왼쪽은 MSB와 동일한 값으로 채움 == x를 2의 n승으로 나눈값과 동일함(음수 부호 유지)

x>>>n(논리 시프트) : 오른쪽으로 n만큼 이동, 왼쪽은 모두 0으로 채움(음수 부호가 유지되지 않음)


### < 비트 마스킹 >

어떤 데이터의 틁정 위치의 비트만 표시하거나 가리는 연산
1. and연산(&)을 활용하여 특정 비트만 남겨보자
   
2바이트의 0xABCD가 존재할 때 상위 8비트를 없애고 하위 8비트에 해당하는 0xCD만 남기기

주어진 데이터와 0x00FF( 0000000011111111) 를 &연산해주면 된다.

<img width="1330" height="520" alt="image" src="https://github.com/user-attachments/assets/ea0cc12e-a2fb-45c4-ab45-f452e015a7c7" />

2. 32비트(4바이트)의 데이터 0x12345678 가 존재할 때, 상위 1바이트의 데이터( 0x12) 만 가져오는 방법

방1) 24번 우측으로 논리 시프트 수행한다 >>>24

방2) 24번 우측으로 산술 시프트 >>24 후, 0x000000FF와 and 연산 하기

<img width="1262" height="112" alt="image" src="https://github.com/user-attachments/assets/4c8a4445-e67b-4c89-b44f-c29a94f9e7ed" />


## 인코딩,디코딩 







